#!/usr/bin/env node

/* eslint-disable no-process-exit */
'use strict';

const { finished } = require('node:stream/promises');

const hlsdump = require('commander');
hlsdump.version('0.0.0')
   .usage('[options] <url>')
   .option('-o, --output <path>', 'target file')
   .option('-u, --udp [host:port]', 'relay TS over UDP', (val) => {

     const r = { host: 'localhost', port: 1234 };
     if (val) {
       const s = val.split(':');
       if (s.length === 1) {
         r.port = parseInt(s[0], 10);
       } else {
         r.host = s[0];
         r.port = parseInt(s[1], 10);
       }
     }
     return r;
   })
   .option('-b, --buffer-size <bytes>|full', 'try to buffer <bytes> of input data (implies -s)', (val) => {

     if (val === 'full') return 0x80000000 - 1;
     return parseInt(val, 0);
   })
   .option('-s, --sync', 'clock sync using stream PCR')
   .option('-f, --full-stream', 'fetch all stream data')
   .option('-c, --concurrent <count>', 'fetch using concurrent connections', parseInt)
   .option('--cookie <data>', 'add cookie header to key requests')
   .option('--key <hex>', 'use oob key for decrypting segments', (opt) => Buffer.from(opt, 'hex'))
   .parse(process.argv);

const src = hlsdump.args[0];
if (!src) {
  hlsdump.help();
  process.exit(-1);
}

(async () => {

  try {
    const { run } = await import('../lib/hlsdump.mjs');

    const startTime = performance.now();

    await run(src, Object.assign(hlsdump.opts(), {
      started(reader) {

        // Report "ready" delay

        reader.on('ready', () => {

          const delay = performance.now() - startTime;
          console.error(`"ready" after delay of ${delay.toFixed(2)} ms`);
        });

        // Report downloaded segment bitrates

        let totalDuration = 0;
        reader.on('segment', (/** @type {import("hls-segment-reader").HlsStreamerObject} */segmentInfo) => {

          let downloadSize = 0;

          segmentInfo.stream.on('data', (chunk) => downloadSize += chunk.byteLength);

          // TODO: use a completed property instead

          finished(segmentInfo.stream)
            .catch(() => undefined)
            .then(() => {

              const duration = segmentInfo.segment?.entry.duration ?? 0;

              totalDuration += duration;

              console.error('segment done at ' + totalDuration.toFixed(0) + ' seconds, avg bitrate (kbps):', (downloadSize / (duration * 1024 / 8)).toFixed(1));
            });
        });
      },
      problem(err) {

        console.error('PROBLEM', err);
      }
    }));
  }
  catch (err) {
    console.error('FAILED', err);
    process.exit(1);
  }

  console.error('stream complete');
})();
